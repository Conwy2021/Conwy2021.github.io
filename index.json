[{"categories":["区块链"],"content":"事件相关信息 公链 以太坊链 黑客地址 0xa9bf70a420d364e923c74448d9d817d3f2a77822 攻击合约 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 地址 0x3212b29e33587a00fb1c83346f5dbfa69a458923 精度位 8 也就是为什么我们在交易记录中看到他的数字都是小数点后8位的原因 另外这个代币是ERC777 imBTC (ERC-777) 是Tokenlon 在以太坊上发行的BTC 锚定币 借贷合约lendf.me 0x0eee3e3828a45f7601d5f54bf49bb01d1a9df5ea interestRateModel合约的实现地址 利率算法合约 0x9a18c4d9587344f2b15686aa67ee7e5c4b00d549 （这里并没有用到） 预言机合约 0xb620707637c5b2cc49843a03d90e28d9abbda149 （这里并没有用到） lendf.me 调用oracle函数返回价格用的 攻击者先给0x538359785a8d5ab1a741a0ba94f26a800759d91d 打了 21595 imBTC 交易hash 0x88fa4e8609baac44189a58faf7cb740cf35308957832ffd6656999229fea689f (使用链必追查询，也可以进入合约地址的ERC-20 Token Txns 查到) ","date":"2022-12-28","objectID":"/lendfme_shijianfenxi/:1:0","tags":["事件篇"],"title":"Lendfme事件分析","uri":"/lendfme_shijianfenxi/"},{"categories":["区块链"],"content":"攻击流程 先上结论： 攻击者的思路是我提取我在借贷合约lendf.me（后续简称lendf.me）中的余额后，lendf.me中我的余额没有减少，却增加了。换句话说我提款后我在lendf.me的余额应该是减少的，实际却没有减少。注意是借贷合约lendf.me中的余额，用户在lendf.me中存的钱会保存在balance.principal中（结构体中的一个参数 我叫他本金）也就这个参数保存了用户在lendf.me合约中余额。 我们先分析他的第一笔攻击交易 0xe49304cd3edccf32069dcbbb5df7ac3b8678daad34d0ad1927aa725a8966d52a 地址：https://etherscan.io/tx/0xe49304cd3edccf32069dcbbb5df7ac3b8678daad34d0ad1927aa725a8966d52a 请注意，这是攻击的第一笔交易，攻击合约目前有21595个imBTC代币。攻击合约之前是没有在lendf.me存过款的，所以我在单看这笔交易时，其实没发现什么问题。 下面我们看下代码调用过程的，通过分析代码的调用，看看能发现什么新线索。 使用工具blocksec。 红框部分是这笔交易的第一次supply（存款操作）函数的调用 注意 EVENT中的amount=21,594, startingBalance=0, newBalance=21,594 说的意思是转入了21,594，刚开始本金是0，更新后的本金是21,594.也证实了这是攻击合约第一次在存款。 我们来看下这笔交易的第二次 supply EVENT中amount=1, startingBalance=0, newBalance=21,595 说的意思是转入了1，刚开始本金是0，更新后的本金是21956。 请注意我们在看ETH浏览器的交易中是，他是有withdraw（提款）的。我们看代码第二次调用时supply 中的imBTC.transferFrom 方法是与第一次不同的 其中多了第4层call，其中就含有Lendf.Me.withdraw方法的调用。 我们也在函数调用中看到攻击合约提取了21594个imBTC。这里发现两个问题， 1、 第二次transferFrom 中多了个withdraw方法。 2、 第二次supply更新后的本金是21955。提取21594 后本金本应该减少的。 先上答案。 1、 imBTC.transferFrom 方法存在重入 2、 重入导致攻击合约在lendf.me中余额变化异常，重点是攻击合约在lendf.me的余额记录。 第一个问题的解释，哪里重入了。 ImBTC是ERC777合约 这个合约会在转账时通知目标合约谁给你转钱了。也就是在通知这里有重入。（这个地方需要自己补充下相关知识，ERC777和ERC1820） LendfMe.sol imBTC.sol ​ 攻击合约在tokenToSend中重入withdraw函数。 第二个问题的解释，重入导致了什么问题。 LendfMe.sol Balance.principal 保存的是用户在lendf.me金额，在第二次supply中，攻击合约同过重入提取了之前存入的21594后，重入函数中withdraw函数执行完成。 Withdraw函数中是有正确的更改用户在合约的余额的。 此时 balance.principal 其实是0 的。也是正确的数值。 重入函数中withdraw函数执行完成后，转账函数进而执行完成。（也就是交易详情为什么withdraw在第二次supply前面的原因） 继续进行1590行后的操作，localResults.userSupplyUpdated存的是21594+1。再更新为用户的余额就是21595。也就是supply的余额覆盖了正确的数值。 正常用户的余额应该是1。 localResults.userSupplyUpdated存的是21594+1的由来，是第一次supply的21594，加上第二次supply中的1。 补充说下：calculateBalance函数是计算你存入期间本金+利息。我们这一笔交易没有利息。 以上就是这次攻击的分析，总结下： 重点就是用户第一次存入了21594，合约中本金是21594.第二次存入1，提取21594，合约中本金却是21595。 下面按数据变化分析整个流程： 第一笔 攻击交易：0xe49304cd3edccf32069dcbbb5df7ac3b8678daad34d0ad1927aa725a8966d52a 时间 Apr-19-2020 12:58:43 AM +UTC 交易过程 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 21595 Lendf.Me imBTC 29134710218 交易动作 Lendf.Me.supply(asset=imBTC, amount=21594)（第一次正常访问） 转账交易 0x538359785a8d5ab1a741a0ba94f26a800759d91d -\u003e Lendf.Me imBTC 21594 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 1 Lendf.Me imBTC 29134731812 交易动作 Lendf.Me.supply(asset=imBTC, amount=1)（第二次supply 重入withdraw） 转账交易 0x538359785a8d5ab1a741a0ba94f26a800759d91d -\u003e Lendf.Me imBTC 1 **正常交易的账号余额应为 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 0 Lendf.Me imBTC 29134731813 withdraw Lendf.Me -\u003e 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 21594 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 21594 Lendf.Me imBTC 29134710219 Lendf.Me合约用户的余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 21595 重点就是这个Lendf.Me合约用户的余额。这个数据看第二笔交易查到的。 这边附上 查看攻击合约的代码。使用工具https://library.dedaub.com/decompile _tokensToSend = 1; 表示第一次正常supply _tokensToSend = 0; 表示第二次重入supply 重入代码为 附上第二，三次交易数据交易流程 第二笔 攻击交易：0xae7d664bdfcc54220df4f18d339005c6faf6e62c9ca79c56387bc0389274363b 时间 Apr-19-2020 12:58:55 AM +UTC 交易过程 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 21594 Lendf.Me imBTC 29134710219 交易动作 Lendf.Me.supply(asset=imBTC, amount=21593) 转账交易 0x538359785a8d5ab1a741a0ba94f26a800759d91d -\u003e Lendf.Me imBTC 21593 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 1 Lendf.Me imBTC 29134731812 交易动作 Lendf.Me.supply(asset=imBTC, amount=1) 转账交易 0x538359785a8d5ab1a741a0ba94f26a800759d91d -\u003e Lendf.Me imBTC 1 **正常交易的账号余额应为 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 0 Lendf.Me imBTC 29134731813 withdraw Lendf.Me -\u003e 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 43188 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 43188 Lendf.Me imBTC 29134688625 Lendf.Me合约用户余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 43189 第三笔 攻击交易：0xa0e7c8e933be65854bee69df3816a07be37e108c43bbe7c7f2c3da01b79ad95e 时间 Apr-19-2020 12:59:19 AM +UTC 交易过程 账号余额 0x538359785a8d5ab1a741a0ba94f26a800759d91d imBTC 43188 Lendf.Me imBTC 29134688625 交易动作 Lendf.Me.supply(asset=imBTC, amount=43187) 转账交易 0x53","date":"2022-12-28","objectID":"/lendfme_shijianfenxi/:2:0","tags":["事件篇"],"title":"Lendfme事件分析","uri":"/lendfme_shijianfenxi/"},{"categories":["区块链"],"content":"Lendfme 借贷合约存储利率分析 Lendfme是模仿compound的，所有很多资料 我这看的是compound的。 Compound 18年9月发布v1。Lendfme模仿的也是这个版本。 首先我们确定下Lendfme的利率算法(核心问题)：根据白皮书（https://compound.finance/documents/Compound.Whitepaper.v04.pdf）和实际代码写法。Lendfme的利率计算方式和传统的存在不同。 传统的利率算法：(1+10%)N N表示周期 Lendfme利率算法：（1+10% *N） 也就是说 在一段多周期的计算中，Lendfme是没有按每个周期的结果进行累加计算的。 存款利率变化时 传统的利率算法：(1+10%)N-1*(1+20%) N表示周期 Lendfme利率算法：（1+10% *(N-1))*(1+20%) 举个例子：存款利率10%每天（每个周期），存5天（多周期） 传统我们存款利息的算法: Lendfme存款利息的算法: 100 *(1+10% *5) 存款利率变化时 传统我们存款利息的算法: 100 *(1+10%)4 *(1+20%) Lendfme存款利息的算法: 100 *(1+10%*4) *(1+20%) 分析第一种场景：我们在区块1 小A 存 ，区块2 小B借，区块4 小B借， 区块5 小A提 其中，第一次借款后，存款利率变为10% ，第二次借款后，存款利率变为20%。以区块为周期。 当前场景下的数据为（借款后才会有存款利率，借1表示第一个借操作） 补充说明下：存的是当动作发生时newSupplyIndex，也是动作发生后的SupplyIndex。因为newSupplyIndex会在函数最后更新supplyIndex。 这边假设提款为0，让本金和利息都在用户账本中保存。方便我们理解，也就是说，当提款为0时，表示利息结算操作。 说下这个市场账本（market）和用户账本(balance)。 市场账本market是个全局变量， 在每次存，借，提 会更新整体的总存款，存款利率，存款利率系数，总借款，借款利率，借款系数，并且更新发生这些动作时的*区块号（区块号更新也是重点）*。这里我们只看存款相关的数据。 用户账本balance 也是全局变量记录用户的本金和当时存款时或者提款时的存款利率系数SupplyIndex。 其中 old 和new 表示 SupplyIndex变更标记。每次使用时用old SupplyIndex算出new SupplyIndex。 这个SupplyIndex 会在每次存，借，提 都会更新的。（这个点也是重点） 再加个说明：SupplyIndex 这个值会更新到市场账本market的supplyIndex和用户账本balance的 interestIndex的。以当前场景 ，在小A存在存和提操作时，会把new supplyIndex 更新到自己账本上。 重点：市场账本的SupplyIndex和用户账本的interestIndex。 以当前场景进行计算： 用户提款的金额是多少 100 *1.44/1=144 （这一步是calculateBalance里写的代码计算过程） 等同于 100 *0.1+100*0.1 +120*0.2=144 calculateInterestIndex函数 oldSupplyIndex *(1+old利率*周期)=newSupplyIndex calculateBalance 函数可以理解为结算收益（本金+利息） 本金 * newSupplyIndex/ oldSupplyIndex=新本金 我们细分下每步操作： 存 newSupplyIndex= oldSupplyIndex *(1+old利率*周期)=1*(1+0)=1 SupplyIndex初始默认值是10 ^18^ 这里简化为1，这里的1 其实和以前奥数中表示1份或者1个单位类似 因为这个值会做除数，最后都会被约分掉。 新本金=本金* newSupplyIndex/ oldSupplyIndex=0*1/1=0 后面有个add 操作会加上你传入的值 我们假设存100 userSupplyUpdated=0+100=100 这个值会在后面更新到用户账本 更新区块号为当前区块为 1 更新newSupplyIndex至市场账本和用户账本 借1（第一个借操作） 借款时只更新SupplyIndex oldSupplyIndex*(1+old利率*周期)=newSupplyIndex（计算公式） 1*（1+0*1）=1 注意此时的old利率是0 更新至市场账本 借2 oldSupplyIndex*(1+old利率*周期)=newSupplyIndex（计算公式） 1*(1+10%*2)=1.2 注意此时的old利率是10%,过了两个周期（以块为周期） 更新至市场账本 提 oldSupplyIndex*(1+old利率*周期)=newSupplyIndex（计算公式） 1.2*(1+20%*1)=1.44 calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex); 计算用户的总金额 注意这里的计算公式是 用户账本的本金*市场账本算出新的存款利率系数/用户账本存的存款利率系数 calculateBalance 函数的计算公式 ： 本金* newSupplyIndex/ oldSupplyIndex=新本金 所以当前用户余额 为 100*1.44/1 =144 更新newSupplyIndex 1.44 至市场账本和用户账本。 我们再进一步计算下 当第6块时用户的本金+利息是多少 按之前的想法 提款0 在第6块 表示 计算第6块时的本金和利息。 计算如下 calculateInterestIndex函数 公式如下 oldSupplyIndex*(1+old利率*周期)=newSupplyIndex 1.44*（1+20% *1）=1.728 calculateBalance函数 公式如下 本金 * newSupplyIndex/ oldSupplyIndex=新本金 144 *1.728/1.44 =144*1.2=1728 更新 newSupplyIndex 1.728至市场账本和用户账本。 我们再多算一步进行验证，第7块有人还钱了导致存款利率降低为10%，我们在第8块 计算下用户的总金额 有人还钱存款利率降低至10% calculateInterestIndex函数 公式如下 oldSupplyIndex*(1+old利率*周期)=newSupplyIndex 1.728 *（1+20%*1）=2.0736 更新newSupplyIndex至市场账本。注意这里是没有更新用户账本的 第8区块 计算 calculateInterestIndex函数 公式如下 oldSupplyIndex*(1+old利率 *周期)=newSupplyIndex 这里周期为1的原因是之前区块7的时候我们更新了区块号。 2.0736 *（1+10% *1）=2.28096 -\u003e 1.728*(1+20%)(1+10%) calculateBalance函数 公式如下 本金 * newSupplyIndex/ oldSupplyIndex=新本金 （oldSupplyIndex是用户账本中的值） 172.8 *2.28096/1.728 =228.096 等同于：172.8 *(1+20%)*(1+10%)=228.096 其中乘以1+20%是第7块的总金额 乘以1+10%是第8块的总金额 同时我们也看出newSupplyIndex/ oldSupplyIndex 就是存款 利率的累乘值。 ","date":"2022-12-18","objectID":"/lendfme%E5%88%A9%E7%8E%87%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/:1:0","tags":["算法篇"],"title":"lendfme利率存储分析","uri":"/lendfme%E5%88%A9%E7%8E%87%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"},{"categories":["区块链"],"content":"初学uniswap v2 抵押挖矿 不明白其中算法 rewardPerTokenStored.add( lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply) ); 是如何来的。核心实现函数为modifier updateReward()。 网上的资料也比较少。所以自己把学习过程记录下（我会尽量让自己的分析正确无误，不误导大家）。 首先我还是找到了些资料的。感谢这些优秀的博主分析。 视频分析 Synthetix Staking Rewards Contract Explained: Part 0 - https://youtu.be/6ZO5aYg1GI8 Part 1 - https://youtu.be/LWWsjw3cgDk Part 2 - https://youtu.be/YqpRwJDz3xg Part 3 - https://youtu.be/pFX1-kNrJFU 大致说下 视频从数学公式上 现从传统思路上分析 r(u,a,b) 意思是 代币u 在时间a 到b的 收益 l(u,t) 意思是 用户在t时间点时 代币的数量 对应的代码表示 白话分析： 保存好每个时间点应的自己代币的数量(balanceAt(t))，和这个时间点对应当代币总量（totalSupplyAt(t)）,然后计算每个阶段自己的收益（reward）累加进行计算。 举例分析：（视频里的图，图示化的讲解真的太好了） 先明确下已知信息 大黄的抵押代币是100 小熊的抵押代币是100 按图这个逻辑， 大黄在7秒时进行抵押，14秒时取出。 小熊在9秒时进行抵押，18秒时取出。 我们来计算下大黄的收益 按上面的代码计算（它按1秒 1秒 计算收益） 第1到7秒都是没有收益的 reward=0 第8秒 REWARD_RATE*100/100 = 1R reward=1R 第9秒 REWARD_RATE*100/100 = 1R reward=1R+1R 第10秒 REWARD_RATE*100/200 = 0.5R reward=1R+1R+0.5R 第11秒 REWARD_RATE*100/200 = 0.5R reward=1R+1R+0.5R+0.5R 第12秒 REWARD_RATE*100/200 = 0.5R reward=1R+1R+0.5R+0.5R+0.5R 第13秒 REWARD_RATE*100/200 = 0.5R reward=1R+1R+0.5R+0.5R+0.5R+0.5R 第14秒 REWARD_RATE*100/200 = 0.5R reward=1R+1R+0.5R+0.5R+0.5R+0.5R+0.5R 最后的reward=4.5R 我们可以分析出按这算法来搞 执行是要消耗gas的 是不行的 那么有人会提出 按每一秒算 不行 咱们按时间差算行不行 7到9秒 产出为1R 9到14秒产出为0.5R reward=1R*2+0.5R*5=4.5 这种情景下 我们需要保存每次变化的totalSupply 并且记录变化时的时间戳 按timetamps[]=[0,7,9,14,18] 伪代码为 for(uint i=0;i\u003ctimestamps.length;i++){ uint t=timestamps[i]; uint t1=timestamps[i+1]; reward+=R*(t1-t)*balanceAt(t)[msg.sender]/totalSupplyAt(t) } 验证下这种算法： t=0 t1=7 reward=0 t=7 t1=9 reward=R*2*100/100=2R t=9 t1=14 reward=2R+R*5*100/200=4.5R t=14 t1=18 reward=4.5R+R*4*100/100=8.5R 很显然 虽然步骤少了 但是这只是4个时间点的变化 实际时间变化点是很多的 所以这个方案 是不行的 继续视频中的推导 r(u,a,b) 意思是 代币u 在时间a 到b的 收益 l(u,t) 意思是 用户在t时间点时 代币的数量 首先k 是 8到14秒时 小黄的代币数量 是个常数 我们给提取出来 为什么a=8 开始呢 以为第8秒时才有收益 公式现在推到为这个样子 这一步 补充下说明 我们要记住 这个是按每秒进行计算的 每秒表示变化 其中 1/L(0)+1/L(1)+…+1/L(b) 多写几项方便理解 1/L(0)+1/L(1)+..+1/L(a-1)+1/L(a)+1/L(a+1)+…….+1/L(b) 最后公式为 根据这个公式推演 大黄的收益 小熊的收益 总结下： 当前时刻的s的累加 - 前一个时刻s的累加[account] = account增加的s rewardPerTokenStored 其实是个公共的数据 所有人共享的 它的含义 应该是一定时间段这个时间段代币总量不变的每个代币可以提供多少个奖励代币的累加集合 每当代币的数量有变化时 或者时间存在增量（可以理解成代币的数量变化为0）时 就会进行累加计算 。 当前时刻的s的累加 每次计算完reward后 会更新userRewardPerTokenPaid[account] 就会变成未来一个时刻的减号后面的数字 最后演算下 这个场景 我们根据上面那个有横轴纵轴的图，从图像上分析他的算法。 假设用L(t) 是总收益，一定时间段这个时间段代币总量不变的每个代币可以兑换的奖励币为mn ,mn 会根据代币总量的变化而变化 我们每秒的计算 下 L(t)=m1 *2 + m2 *3 + m3 *2 + m4 *4 计算下 大熊的收益 他抵押代币时的 L(t)为m1 *2 他提取代币时的L(t)为m1 *2 + m2 *3 + m3 *2 + m4 *4 那么收益为 m1 *2 + m2 *3 + m3 *2 + m4 *4 - m1 *2 = m2 *3 + m3 *2 + m4 *4 再乘以他的代币数量100 我们把100 放到里面去 m2 *3*100 + m3 *2*100 + m4 *4*100 可以看出 这个其实就时每个阶段的收益之和 当大熊得到收益后 会把记录下自己领过奖励时的 L(t)=m1 *2 + m2 *3 + m3 *2 + m4 *4 下次再计算时 就用最新的L(t)减去之前的（这里假 设大熊还有代币在池子里） PS：这里大熊实际是把代币都领出去了。下次质押代币时，会先出发modifier updateReward()函数 记录抵押时的L(t)。就像他第一次抵 押一样。 这边再大致说下MasterChef的计算思路 代码 在https://etherscan.io/address/0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd#code 我在他git上没找到 MasterChef是每个区块产生100个奖励代币 SushiToken （他设计在多少区块前奖励是10倍，我们先按没有这个设计理解） 记录 一定区块段这个区块段代币总量不变的每个代币可以兑换的奖励币累加值mn 和自己抵押时对应的mn 然后就是累加mn -自己抵押时对应的mn 核心函数为updatePool() ","date":"2022-08-24","objectID":"/staking_algorithm/:0:0","tags":["算法篇"],"title":" uniswap v2 抵押挖矿 算法分析","uri":"/staking_algorithm/"},{"categories":["hugo"],"content":"常用命令 在blog目录下启动cmd。 执行hugo命令 编译 。 使用hugo 后会自动将改动的文章或者配置，更新到public 目录下 ，实际上传的也是public目录下的文件 执行hugo server -D 本地启动 -D 是可以看到草稿文件的。 执行hugo server 是看不到草稿文件的。 启动后 http://localhost:1313/ 本地访问博客。 草稿文件命令 在文章开头中draft: true 如图 创建文章命令 hugo new post/第二篇测试博客.md （默认是草稿模式） 图片设置 正常做法： 写文章时，在该文章目录下新建文件夹存放照片，引用时采用相对路径。 完成之后，在引用路径前加个 /，比如原来引用方式 ![](imgs/pic_name.png) ，需要修改为 ![](/imgs/pic_name.png) 。 之后将该图片文件夹移动到 static 目录下即可。 注意：如果该文件夹名包含空格可能会不能被显示，支持中文，但是不支持含空格。 其他 文章目录为 \\blog\\content ","date":"2022-08-24","objectID":"/about/hugo%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/:0:0","tags":["hugo"],"title":"hugo写作备忘","uri":"/about/hugo%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/"}]